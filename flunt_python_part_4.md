# Fluent Python
## 第八章 对象引用，可变性与垃圾回收

1. python中对变量的赋值，实质上是为对象添加一个引用的别名，通过别名对该对象进行引用。对象在赋值之前就已经存在。
2. 不同的对象具有不同的id，因此两个对象可以是值相等，即==，但是不会完全相等，即is
3. 元组中不可变对象不可修改，但是可变对象可以进行修改。元组中的可变对象保存的也只是对可变对象的引用。例如`(1,2,3,[1,2,3])`，元组中的列表保存的仅是对该列表的引用，列表可修改
4. 对于列表和可变序列来说`[:]`是对序列做浅复制，而不是创建一个全新的副本。copy模块中提供copy()做浅复制，仅是复制，创建一个新的id，但是不会对内部对可变对象的引用进行复制。deepcopy()，做深复制，创建一个全新副本
5. 尽量不要使用可变类型作为函数参数的默认值，因为在函数中对该参数进行修改时，会同时修改掉原对象。若一定要使用可变参数，可在初始化或使用时建立全新副本进行操作
6. 垃圾回收机制为引用计数，当引用归零，则对象会被当做垃圾回收。del方法删除的是对一个对象的引用，而不是对象本身。
7. python在中存在弱引用，会在对象被清理后留下一定的缓存。弱引用的主要使用就是作为缓存，当有缓存的需要时，可以尝试使用。
8. 对于不可变对象以及小整数，copy的结果就是创建一个对原对象的引用。

## 第九章 Pythonic的对象 使用特殊方法和约定结构

1. 对于`@classmethod`和`@staticmethod`，前一个用来装饰类方法，定义备用构造方法，使用类方法来创建一个新的实例，或对类属性进行修改，操作对象是类。后一个用来装饰静态方法，也可直接在模块中定义普通方法来使用。
2. 定义__format__来实现format函数
3. `@property`可以用来装饰类中的方法，使方法能够作为属性来使用
4. 类属性可以通过继承进行覆盖
5. `__slots__`，定义可包含各个可访问实例属性，虽然可使用改方法进行实例属性访问的限制，但是不推荐
6. 实例属性前添加双下划线`__`，默认该属性为私有属性，但使仍然可通过找到特殊处理后的属性名进行修改，单下划线`_`默认为受保护的属性，python中所有的实例属性均可经过正确属性名称进行修改

## 第十章 序列的修改，散列，切片

1. 类的初始化过程中使用__init__，(*)可以接受任意多个参数，(**)可以接受任意多个关键字参数
2. python中只要在类里面实现__len__和__getitem__两个方法，就可以作为序列进行使用，只要实现了__getitem__既可支持迭代
3. 切片的原理是slice(start,end,step),slice有个indices方法，可以非常好的处理索引缺失，负数索引以及长度超过序列的切片,在__getitem__中，可以自己实现处理切片的方式。
```
   举个栗子：
   >>>slice(None,10,2).indices(5)
   (0,5,2)

```
4. 通常通过实现__getattr__方法来获取属性，该方法通常需要与__setattr__共同实现，以确保操作对象的一致性
5. operator模块中以函数形式提供了所有的中缀运算符，方便使用。zip()函数可以很方便的同时迭代多个可迭代对象并以元组的方式进行返回。zip_longest()以最长的迭代对象进行返回，对长度不够的返回值以参数fillvalue进行填充。
6. 实现__hash__方法，使对象成为可散列对象。散列的方式和算法可以自己实现。

## 第十一章 接口，协议与抽象基类

1. 不建议用户自己实现抽象基类，容易过度设计.通常可通过常规设计来实现
2. 类中的方法就是接口，包括类自己实现的方法，继承的方法和一些特殊方法.接口是一个类中特定方法的集合
3. python可以在运行的过程中为类添加属性和方法，不改动源码。
4. 在collections.abc中定义有最常用的抽象基类，包含迭代，映射，哈希等
5. 抽象基类的定义
```
   举个栗子：
   import abc
   class Fun(abc.ABC):
   or
   class Fun(metaclass=abc.ABCMeta)(version 3.4 以前)

       @abc.abstractmethod
       def fun(self):

  抽象基类继承abc.ABC,定义抽象方法不需要具体实现。继承该基类的类则必须在类中具体实现这个抽象方法
  虚拟子类，将一个类注册为抽象基类的虚拟子类，而不用继承该基类
  @Fun.register
  class SubFun():

    def fun(self):
        pass

  或者
  class SubFun():

      def fun(self):
          pass
  Fun.register(SubFun)
```

## 第十二章 继承与多重继承，继承的优缺点

1. 对于内置类型的的子类化，用户定义的方法不能覆盖内置类型的特殊方法
2. 针对多重继承的解析，python是从左往右查找继承的方法。
```
   举个栗子：
   class Func(A,B,C):
       pass
   若A，B，C中都有fun()函数，则调用时会首先查找到A的fun()函数并使用
   也可以使用super()函数来指定使用哪一个父类的方法
```
3. 对于内置类型的扩展，如dict，list，str可以使用UserDict，UserList，UserString进行扩展
4. 继承不应该过于复杂！

## 第十三章 运算符重载

运算符的重载一般应用于实现自己自定义类的计算以及比较，一般情况下内置运算方法已足够使用。运算符重载方式是在类里面重写运算的特殊方法，如__add__，重写即可重新表示+方法
